name: CI/CD
on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
      IMAGE_REPO: polaris-secuone-dashboard
    outputs:
      image_latest: ${{ steps.vars.outputs.image_latest }}
      image_sha:    ${{ steps.vars.outputs.image_sha }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: maven

      # 1) 레포 전체에서 pom.xml / build.gradle(.kts) 검색 → 모듈 디렉터리/툴 출력
      - name: Locate module (pom/gradle)
        id: module
        run: |
          set -e
          FILE="$(git ls-files '**/pom.xml' '**/build.gradle' '**/build.gradle.kts' | head -n1 || true)"
          if [ -z "$FILE" ]; then
            echo "No Maven/Gradle build file found (searched recursively)."; exit 1
          fi
          DIR="$(dirname "$FILE")"
          echo "module_dir=$DIR" >> $GITHUB_OUTPUT
          if [[ "$FILE" == *pom.xml ]]; then
            echo "tool=maven" >> $GITHUB_OUTPUT
          else
            echo "tool=gradle" >> $GITHUB_OUTPUT
          fi
          echo "Found build file: $FILE"

      # 2) Maven 빌드 (모듈 경로 지정)
      - name: Build (Maven)
        if: steps.module.outputs.tool == 'maven'
        run: mvn -B -DskipTests -f "${{ steps.module.outputs.module_dir }}/pom.xml" package

      # 3) Gradle 빌드 (모듈 경로에서 wrapper 우선)
      - uses: gradle/actions/setup-gradle@v4
        if: steps.module.outputs.tool == 'gradle'
      - name: Build (Gradle)
        if: steps.module.outputs.tool == 'gradle'
        working-directory: ${{ steps.module.outputs.module_dir }}
        run: |
          chmod +x ./gradlew || true
          if [ -f ./gradlew ]; then ./gradlew bootJar -x test || ./gradlew build -x test; else gradle build -x test; fi

      # 4) 산출물 JAR 자동 탐색(레포 전체)
      - name: Locate JAR
        id: jar
        run: |
          JAR=$(find . -type f -name "*.jar" -not -name "*sources*" -not -name "*javadoc*" | head -n1)
          echo "jar=$JAR" >> $GITHUB_OUTPUT
          echo "Found JAR: $JAR"
          test -n "$JAR" || (echo "JAR not found"; exit 1)

      # 5) 이미지 태그 계산(잡 출력으로 전달)
      - name: Set image names
        id: vars
        run: |
          echo "image_latest=${REGISTRY}/${{ github.repository_owner }}/${IMAGE_REPO}:latest" >> $GITHUB_OUTPUT
          echo "image_sha=${REGISTRY}/${{ github.repository_owner }}/${IMAGE_REPO}:sha-${{ github.sha }}" >> $GITHUB_OUTPUT

      # 6) GHCR 로그인(GITHUB_TOKEN)
      - name: Login GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      # 7) Docker 빌드 & 푸시 (JAR 경로 주입)
      - name: Build & Push image
        run: |
          docker build \
            --build-arg JAR_FILE="${{ steps.jar.outputs.jar }}" \
            -t "${{ steps.vars.outputs.image_latest }}" \
            -t "${{ steps.vars.outputs.image_sha }}" .
          docker push "${{ steps.vars.outputs.image_latest }}"
          docker push "${{ steps.vars.outputs.image_sha }}"

  deploy:
    needs: build-and-push
    runs-on: self-hosted
    env:
      IMAGE_LATEST: ${{ needs.build-and-push.outputs.image_latest }}
    steps:
      - name: Login GHCR (read)
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Pull & Up
        run: |
          cd /home/tomcat/secuone
          docker pull "$IMAGE_LATEST"
          docker compose up -d
          docker image prune -f
